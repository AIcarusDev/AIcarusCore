# 专注聊天模式主动循环改造计划

## 1. 背景与目标

**当前状态**: 目前的专注聊天模式 (`ChatSession`) 是一个被动的事件处理器。它完全依赖于外部事件（主要是新消息）来触发其思考和响应流程。如果没有新消息，`ChatSession` 就会处于空闲状态，无法进行连续的、自我驱动的思考。

**改造目标**: 借鉴外部项目 `heartFC_chat.py` 的设计思想，将 `ChatSession` 从被动模式改造为**主动循环模式**。改造后的 `ChatSession` 将拥有自己的“心跳”，能够在没有新消息的情况下，通过内置的循环和等待机制，持续地进行“观察-思考-决策”的过程，实现真正的“再思考”能力。

## 2. 核心思路

为了实现更清晰的职责分离和更好的代码可维护性，我们将采用**拆分文件**的策略。核心的主动循环逻辑将被封装在一个**新的类 `FocusChatCycler`** 中，该类位于一个新的文件 `focus_chat_cycler.py` 内。

`ChatSession` 类将回归其核心职责：作为会话的**状态和数据容器**。它将创建并持有一个 `FocusChatCycler` 实例，并将循环的控制权完全委托给它。

---

## 3. 详细改造计划

### 第一步：创建 `focus_chat_cycler.py` 和 `FocusChatCycler` 类

这是本次改造的基础，我们将创建一个专用于处理主动循环的引擎。

- **新文件**: `AIcarusCore/src/sub_consciousness/focus_chat_cycler.py`
- **新类**: `FocusChatCycler`

**`FocusChatCycler` 的职责**:

1.  **持有 `ChatSession` 引用**: 在 `__init__(self, session: "ChatSession")` 中接收并保存 `ChatSession` 的实例，以便访问会话状态和依赖（如 `llm_client`, `event_storage` 等）。
2.  **管理循环生命周期**:
    - 包含 `_loop_active`, `_loop_task`, `_shutting_down` 等状态属性。
    - 实现 `start()` 方法来创建并启动主循环 `_chat_loop` 任务。
    - 实现 `shutdown()` 方法来优雅地停止循环任务。
3.  **实现主循环 `_chat_loop()`**:
    - 包含 `while` 循环，作为思考、决策和行动的核心驱动。
    - 将原 `process_event` 的所有核心逻辑都迁移到这里。
4.  **实现等待逻辑 `_wait_for_new_event_or_timeout()`**:
    - 实现等待新事件或超时的机制，以驱动无消息时的“再思考”。

### 第二步：改造 `ChatSession` - 减负并集成 Cycler

`ChatSession` 将变得更轻量，主要负责数据和状态管理，并将控制权交给 `FocusChatCycler`。

1.  **集成 `FocusChatCycler`**:
    - 在 `ChatSession.__init__` 方法中，创建 `FocusChatCycler` 的实例：
      ```python
      from .focus_chat_cycler import FocusChatCycler
      # ...
      self.cycler = FocusChatCycler(self)
      ```
2.  **委托生命周期控制**:
    - **`activate()`**: 方法逻辑简化为直接调用 `self.cycler.start()`。
    - **`deactivate()`**: 方法逻辑简化为直接调用 `self.cycler.shutdown()`。
3.  **移除旧逻辑**:
    - `process_event` 方法将被完全移除。
    - `_build_prompt` 等与思考流程紧密相关的方法，可以考虑是否也一并移动到 `FocusChatCycler` 中，以进一步净化 `ChatSession` 的职责。

### 第三步：改造 `ChatSessionManager` - 适应新的会话结构

`ChatSessionManager` 的改动与原计划一致，但现在它操作的是一个持有 `Cycler` 的 `ChatSession`。

- **`handle_incoming_message()`**:
  - **职责简化**: 不再调用 `session.process_event(event)`。
  - **新职责**: 当收到新消息时，主要任务是确保对应的 `ChatSession` 处于激活状态。如果会话未激活（例如被`@`时），则调用 `session.activate()` 来启动它的 `Cycler`。新消息本身会被 `Cycler` 的内部循环自动发现和处理。
- **`deactivate_session()`**:
  - 需要修改为调用 `session.deactivate()`（内部会调用 `cycler.shutdown()`），以确保 `asyncio.Task` 被正确、优雅地关闭。

### 第四步：后勤支持 - `EventStorageService` 的潜在修改

此步骤与原计划相同，对于实现高效的等待逻辑至关重要。

- **`has_new_events_since(conversation_id: str, timestamp: float) -> bool` (建议新增)**:
  - 这个方法应该直接在数据库层面执行一个高效的查询（例如 `COUNT` 或 `LIMIT 1`），只判断是否存在时间戳大于 `timestamp` 的新事件，而不是返回所有事件数据。这将大大降低 `_chat_loop` 在等待期间的开销。

## 4. 预期效果

改造完成后，专注聊天模式将从一个被动的响应器转变为一个主动的思考者。即使在没有新消息的“冷场”期间，它也会以设定的频率（由超时决定）周期性地重新评估当前对话状态，决定是继续等待、主动发言还是结束专注，从而表现出更强的对话连续性和主动性。
