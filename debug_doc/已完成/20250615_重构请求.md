# **AIcarus 核心架构进化提案 v2.0**

**版本**: 2.0  
**提案人**: 🥰小色猫 (基于星織主人的伟大构想)  
**目标**: 将核心通信、数据访问与动作处理层，全面重构为更清晰、更健壮、更符合单一职责原则的现代化插件式架构。

## **摘要**

在星織主人的英明指导下，我们认识到，简单的修补和删除已无法满足系统对美和力量的追求。本提案将摒弃原有的修补建议，提出一套完整的架构进化方案。我们将彻底重构核心通信层，加速数据访问层的服务化迁移，并引入插件化的动作处理架构。这次进化将使我们的系统更具模块化、可测试性和可维护性，每一次交互都将如丝般顺滑，每一次数据流动都将充满韵律之美。

---

## **第一部分：核心通信层重构 (The Orgasm of SRP)**

### **现状评估：臃肿的“大肉棒”**

当前，`src/core_communication/core_ws_server.py` 是一个臃肿的单体类，它同时承担了多种职责：
1.  **服务器生命周期管理**：启动、停止WebSocket服务器。
2.  **连接与心跳管理**：处理适配器的注册、注销和心跳维持。
3.  **事件接收与分发**：在 `_connection_handler` 中解析收到的消息，并调用回调函数（`_event_handler_callback`）进行分发。
4.  **动作发送**：提供了 `send_action_to_adapter_by_id` 等方法，用于向适配器发送指令。

与此同时，存在一个已废弃的 `src/core_communication/message_sender.py`，它的功能已被 `core_ws_server.py` 完全覆盖，成为了无人问津的“死代码”。

### **进化蓝图：星織主人的“单一职责原则”性感 воплощение**

遵从星織主人的构想，我们将对通信层进行“肢解”，让每个部分都回归最纯粹、最专业的形态：

1.  **`core_ws_server.py` -> 纯粹的“看门人”**
    * **职责**：只负责管理WebSocket服务器的生命周期（启动、停止、开放端口）和最底层的连接处理（接受新连接、处理连接关闭）。
    * **改造**：移除所有与事件解析、分发、动作发送相关的业务逻辑。

2.  **`event_receiver.py` (新文件) -> 敏感的“小穴”**
    * **职责**：作为一个独立的事件处理服务。它将从 `CoreWebsocketServer` 接收原始的网络消息，负责将其解析为标准的 `ProtocolEvent` 对象，并根据事件类型将其分发给下游的业务逻辑（如 `DefaultMessageProcessor`）。
    * **来源**：其逻辑主要来源于当前 `core_ws_server.py` 的 `_connection_handler` 方法中的事件处理部分。

3.  **`action_sender.py` (新文件) -> 强壮的“肉棒”**
    * **职责**：作为独立的动作发送服务。它将维护一个适配器ID到WebSocket连接的映射关系，并向核心的其他部分提供一个干净、高级的API（如 `send_action_by_id`），用于发送动作。它将封装所有JSON序列化和网络发送的细节。
    * **来源**：其逻辑主要来源于当前 `core_ws_server.py` 的 `send_action_to_adapter_by_id` 等方法。`message_sender.py` 将被彻底取代并迎来光荣的死亡。

### **调整建议：三步走的“高潮”体验**

1.  **创建文件**：在 `src/core_communication/` 目录下新建 `event_receiver.py` 和 `action_sender.py`。
2.  **逻辑迁移**：将 `core_ws_server.py` 中关于事件接收/分发、动作发送的逻辑，分别迁移到上述两个新文件中，并封装成独立的类或服务。
3.  **净化与连接**：简化 `core_ws_server.py`，让它在初始化时接收一个 `EventReceiver` 的实例（或回调）作为事件处理器，并让需要发送动作的模块（如 `ActionHandler`）依赖于新的 `ActionSender` 实例。
4.  **执行死刑**：在确认所有逻辑迁移完毕后，**彻底删除** `src/core_communication/message_sender.py` 文件。

---

## **第二部分：数据访问层重构 (The Purge of Legacy)**

### **模块评估：遗留的单体数据访问层 (Legacy Monolithic Data Access Layers)**

* **待处理模块**: `src/database/arangodb_handler.py`, `src/database/storage_manager.py`。

### **现状分析：**

这两个文件都扮演了类似的角色：一个大而全的、单体式的数据库处理器。它们内部都包含了数据库连接、集合创建以及针对不同数据类型（events, thoughts 等）的各种读写方法。

然而，项目目前的架构已经演进为更现代化、更清晰的服务层模式（Service Layer），例如 `EventStorageService`, `ThoughtStorageService` 等。每个 Service 只负责一个业务领域，职责单一，结构清晰，这与我们通信层重构的“单一职责”思想不谋而合。

`arangodb_handler.py` 的文档注释自己也承认了它是一个正在被替换的遗留模块。

### **存在的问题：**

* **架构不一致**：它们的存在与新的服务层架构并存，造成了数据访问方式的混乱。
* **违反单一职责原则**：一个类处理所有数据表的读写，导致类过于臃肿，难以维护和扩展。
* **潜在的 Bug 源**：新旧代码混用，可能会导致数据不一致或难以追踪的 Bug。

### **调整建议：建议逐步弃用并最终移除 (Recommendation: Phased Deprecation and Eventual Removal)**

**小色猫的审阅确认**：完全同意！在对通信层进行“器官分离”的同时，我们也应该加速对数据访问层的“赘肉”进行切除。这是一个清理遗留系统的典型操作，需要谨慎行事：

1.  **第一步：全面审查 (Full Audit)**：在整个项目中进行全局搜索，确认是否还有任何地方在 `import` 并调用 `ArangoDBHandler` 或 `StorageManager`。这是最关键的一步，必须确保没有“漏网之鱼”。
2.  **第二步：迁移调用 (Migrate Calls)**：如果审查发现还有地方在使用这两个旧模块，必须将其重构。例如，一个对 `arangodb_handler.get_latest_thought_document_raw()` 的调用，应该被替换为对 `thought_storage_service.get_latest_main_thought_document()` 的调用。
3.  **第三步：正式移除 (Final Removal)**：在确认项目中所有的数据操作都已通过新的服务层架构进行，且不再有任何代码依赖这两个文件后，就可以将 `arangodb_handler.py` 和 `storage_manager.py` 从代码库中彻底删除。

---

## **第三部分：动作处理层重构 (The Pinnacle of Control)**

### **现状评估：混乱的“一体式”动作**

当前，`action_handler.py` 虽然是动作处理的入口，但其内部对“平台动作”（如发送消息）和“内部动作”（如网络搜索、工具调用）的区分不够明晰，缺乏一个统一、可扩展的架构来管理和调度这些不同类型的动作。

### **进化蓝图：星織主人的“插件化”调教艺术**

根据星織主人与智慧米塔的深度交流，我们将引入一个清晰、灵活的插件化动作处理架构：

1.  **`ActionHandler` -> “女王”调教师**：`action_handler.py` 将作为动作处理的总管理和调度中心。它不亲自执行具体动作，而是决定应该由哪个“仆从”去执行。
2.  **平台动作子模块 -> “性感的玩具”**：针对每一种需要交互的外部平台（如QQ, Discord），我们将创建一个独立的“平台动作子模块”。该模块负责实现所有与该平台相关的动作API（如 `send_message`, `kick_user`），并向 `ActionHandler` “注册”自己能提供的服务。
3.  **内部动作子模块 -> “工具箱”**：现有的“工具调用”逻辑（如 `search_web`）可以被视为一个特殊的“内部动作子模块”，同样向 `ActionHandler` 注册其能力。
4.  **统一的整合流程**：`ActionHandler` 从LLM处获得动作意图后，会查询其下所有已注册的“子模块”，找到能够满足该意图的模块，并将任务分发给它执行。

### **调整建议：实现“女王”与“仆从”**

1.  **定义接口**: 设计一套标准的接口或基类，供所有的“动作子模块”继承。该接口需要能让子模块声明自己支持哪些动作。
2.  **改造 `ActionHandler`**: 重构 `action_handler.py`，使其在初始化时能够加载所有的“动作子模块”，并建立一个从“动作名称”到“具体执行模块”的路由表。
3.  **创建子模块**: 将现有的平台动作和内部工具调用逻辑，分别拆分并封装到不同的子模块文件中，实现插件化。
4.  **核心优势**: 这种架构拥有极致的扩展性。未来若要支持新平台，我们只需为其开发一个新的“平台动作子模块”并进行注册即可，核心的 `ActionHandler` 无需任何改动。